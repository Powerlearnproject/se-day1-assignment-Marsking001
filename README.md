[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=15591129&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering


Explain what software engineering is and discuss its importance in the technology industry.
Software is a program or set of programs containing instructions that provide the desired functionality. Engineering is the process of designing and building something that serves a particular purpose and finds a cost-effective solution to problems. 
There is a dual role of software in the industry. The first one is as a product and the other one is as a vehicle for delivering the product. We will discuss both of them.
As a Product
It delivers computing potential across networks of Hardware.
It enables the Hardware to deliver the expected functionality.
It acts as an information transformer because it produces, manages, acquires, modifies, displays, or transmits information.
 As a Vehicle for Delivering a Product
It provides system functionality (e.g., payroll system).
It controls other software (e.g., an operating system).
It helps build other software (e.g., software tools).


Identify and describe at least three key milestones in the evolution of software engineering.
1. Requirements Gathering
Before moving forward with any project, be sure your business understands the objectives and project scope, first at a high level and then broken down into granular details. Business requirements can be presented in many forms, such as listed on a Word document or written up in user stories for teams that follow an Agile approach.

2. Solution Design & Project Scoping
Once the requirements have been defined and approved by the project stakeholders, the technical team will begin working on a solution design that provides the engineering blueprint for a software solution that fulfills the business requirements. Where requirements focus on “what” the software needs to do, the solution design will focus on “how” it will be built. This milestone will include work on technical specifications, such as the system architecture and data models, as well as outlining the user experience.
It’s important to gather your input from all of the software’s user groups and business stakeholders. Requirements tend to vary between user groups since they use different features of the software. 

3. Pre-Development Planning
Pre-Development planning is typically a short effort where the implementation teams collaborate to address the foundational technical design decisions and project execution plans that will guide all subsequent implementation activities.

The Technical Design team will establish software architecture and development guidelines for the development team to follow. Depending on your project’s requirements, below are some of the key decisions often addressed during this milestone to ensure proper planning:

What software languages, tools, and frameworks will be used in development?
Where will the application be hosted?
What are the scalability requirements for the software?
Are there any special compliance requirements that the software needs to meet?
Will the solution be built using any pre-existing platforms or products?
How will the application data be stored, accessed, and secured?
Are there any 3rd party integrations that the software will require?

List and briefly explain the phases of the Software Development Life Cycle.
Planning
requirements
design and prototype
software development
testing
deployment
maintenance. 
1. Planning
In this phase, the project leads to defining the project’s purpose and the desired result. 
If the team is developing for a customer instead of to market, the project manager meets with them to discuss the product, its purpose, and the results they want to achieve. The team gathers as much information about the product from the customer.
2. Requirements
This second phase of the software development life cycle is often done concurrently with the first. Here, the project lead analyzes the product or client’s goals and decides on the features to aim for as a final goal. Defining and establishing requirements determines what the application will do once launched, the necessary components, and the resources needed to launch it. 
3. Design and Prototype
Once phases 1 and 2 are understood and established, developers can start designing the software. 
The design phase defines how a software application will work. During this phase, teams decide on the programming language, screen layouts, and relevant documentation they will use.
Some of the fundamental aspects developers cover during this phase are:
Architecture: Teams define if they want a specific type of template or if they want to implement any type of industry practice.
User Interface: Teams define the way users will be interacting with the platform. 
Security: Developers must define how they will keep the application secure. This means they need to decide how to protect user data and general app data.
Programming: Define the project’s tech and tool stack. 
4. Software Development 
During this phase, developers start programming. 
If they work on a small project, one developer takes over the coding tasks, while on large projects, the codebase might be worked on by several developers. 
5. Testing 
Often, testing happens in parallel with development, as developers write and test the code they’ve produced before moving on to the next coding task.
During this phase, different types of testing occur, such as code quality, unit testing, integration testing, performance testing, and security testing. 
6. Deployment
The deployment process starts once the testing phase is over and there are no bugs or errors in the development backlog. The team ensures that the software is up-to-date and secure enough for users and pushes it from the development environment to a live environment–usually an app store.
7. Maintenance
At this point, the application is successfully launched and being used. 
Yet this last phase is still important because bugs or errors missed during testing are bound to appear. Simultaneously, by studying user behavior and feedback, the team can start to think about and plan for upgrades. 

Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.
Waterfall is an approach to project management and software development that follows a linear sequence of events. In Waterfall, each phase of the project is gated. Teams cannot advance from one phase of the SDLC to the next until the current phase is complete. Each phase has clearly defined completion criteria. Criteria for the project are generated in the first stage of Waterfall -- the requirements stage -- and codified in documentation. The requirements set forth in the beginning ideally do not change during the course of a development project in this model.
Waterfall suits projects that require a high volume of documentation and have repeatable, predictable processes. It is especially effective for projects with well-defined requirements and minimal expected changes, ensuring consistency and traceable control.
gile is an approach to project management, specifically software development projects, that prioritizes collaboration, continuous delivery and customer feedback. Agile breaks work into iterative steps, which are smaller tasks that can be completed quickly. These iterations are done during sprints. Agile teams complete one sprint before moving onto the next one. Requirements can change at any time in the project based on changing business needs or customer feedback. Future sprints are based on the outcomes of previous sprints.

Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.

Software Developer
The developer is responsible for writing the code and developing the entire software product. Aside from coding, a software developer is responsible for sending updates to the project manager and working closely with other team members, including the designer and QA engineer. 
the kind of software developer you hire for your team depends on your desired software. If you want a mobile application, you need an iOS or an Android developer. However, if you want to develop a web application, you need a front-end, back-end or full-stack developer.  

QA Engineer 
The quality assurance engineer creates tests that identify issues with software before it is deployed. quality engineers monitor every phase of the software development process, including development, testing, debugging and delivery. They ensure that quality is maintained at every stage of the development process and that the final product meets the requirements.
Responsibilities 
Collaborate with stakeholders to understand and clarify software requirements.
Create development standards and procedures for the programmers to follow. 
Confirm that the software meets the requirements before deployment.
Analyse the product to identify bugs and suggest changes to make them more efficient. 
Develop and execute automation scripts using open-source tools. 

A Project Manager
A Project Manager in Software Development is a crucial role responsible for overseeing the planning, execution and delivery of software projects. They align project objectives with business goals, manage resources and mitigate risks. 

Collaborating with cross-functional teams, they ensure smooth coordination and effective communication. Project Managers define project scope, set timelines, allocate resources, and monitor progress to keep projects on track. With technical expertise, leadership skills and knowledge of software development methodologies, they navigate complexities and deliver successful outcomes. Their role ensures projects are completed within time and budget constraints, meeting quality standards and driving organisational success.

Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.
An integrated development environment (IDE) is a software application that helps programmers develop software code efficiently. It increases developer productivity by combining capabilities such as software editing, building, testing, and packaging in an easy-to-use application. Just as writers use text editors and accountants use spreadsheets, software developers use IDEs to make their job easier.
e.g Visual Studio Code, PyCharm

Version control, also known as source control, is the practice of tracking and managing changes to software code. Version control systems are software tools that help software teams manage changes to source code over time. As development environments have accelerated, version control systems help software teams work faster and smarter. They are especially useful for DevOps teams since they help them to reduce development time and increase successful deployments. e.g Github, GNU Bazaar

what are some common challenges faced by software engineers? Provide strategies to overcome these challenges.

1. Lack of Workflow Visibility
You can’t fully control the external events that impact your software development. But you can be in complete control of the internal factors and prepare your team to be highly resilient and respond to all sorts of challenges. it can be overcome Invest in tools that empower your teams to make data-driven decisions:  Project management tools, Engineering analytics tools, Observability & monitoring tools
2. Broken Processes
Your software development processes can be broken at multiple levels. It could be any of the following-
Poor requirement gathering, Scope creep, Code smells, Improper code reviews, Unhelpful documentation and Inefficient CI/CD pipelines. it can be over come From workflow management, to how to scope iterations accurately using data-driven insights, find it all!  
3.Lack of Predictability In Software Delivery 


Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.

Unit testing is done at the code level, where each component is tested individually to ensure their impartiality and analyze their functionality. Automating unit tests is possible and highly recommended in today’s fast-paced development environment. To make a unit test, you should outline what you expect the code to do and write the code, which will check if it is doing what you expect. You should then run the unit test to verify that everything works as expected. 

Integration testing enables software testers to test group units integrated into a system or subsystems; it helps identify any bugs or issues arising from coding errors or integrations between modules. It is possible to automate integration testing.

System testing is performed on an integrated environment comprising the whole application, where all components are assessed against specific business requirements. You can use automation tools for System Testing.

Acceptance testing involves testing the system’s Functional and Non-functional aspects, such as performance, security, usability, accessibility, compatibility, and reliability. Depending on the system’s complexity, it can be done manually or through automation tools

Software quality Testing is a necessary process. It guarantees the software does what it should and meets all the requirements. Skipping testing can lead to severe issues that can mess up the software’s usefulness and how it works. So, don’t forget to give enough time and resources to test your software if you want it to be a hit when you launch it

#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.

Prompt engineering is the process of giving instructions to a generative AI to produce requested results. From content generation to code generation, prompt engineering offers endless possibilities. Explore the latest innovations in prompt engineering and discover how it is shaping the future of AI.

Although generative AI tries to copy humans, it needs precise directions to produce high-quality and relevant output. In prompt engineering, you select the correct formats, phrases, words, and signs that help AI interact more meaningfully with users. Prompt engineers apply their imagination through trial and error by creating a pool of input texts to operate an application’s generative AI effectively.

1.. Making AI Smarter
Prompt Engineering helps make AI better at what it does. By giving clear instructions, we can make sure AI gives us the right answers and does the right things. This is super important in Gen AI, where we want AI to be really good at understanding us.

2. Getting the Right Results
Another reason we use Prompt Engineering is to get the results we want from AI. Whether it’s writing something or showing pictures, prompts help AI know what we’re looking for. This means we get the information or content that matches what we need.

3. Fixing Mistakes and Bias
Prompt Engineering also helps AI from making mistakes or being unfair. By giving the right instructions, we can make sure AI doesn’t say or do things that are wrong or unfair. This makes AI more reliable and trustworthy.

4. Helping People Talk to AI
Prompt Engineering makes it easier for us to talk to AI. Good prompts help us understand how to ask AI for things, making the conversation smoother. This makes people more comfortable using AI, which is important as it becomes a bigger part of our lives.

Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.

vague Prompt: "Tell me about technology."

Improved Prompt: "Explain how 5G technology improves internet speed and connectivity compared to 4G."

Why the Improved Prompt is More Effective:

Clarity: The improved prompt specifies the technology in question (5G) and its comparison with another technology (4G). This focus makes it clear what aspect of technology should be addressed.

Specificity: By asking about the improvements in internet speed and connectivity, the prompt narrows down the topic to particular features and benefits, making it easier to provide a relevant and detailed response.

Conciseness: The revised prompt is concise but packed with relevant details, which helps in generating a precise and informative answer without extraneous information.